{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pynomaina API Documentation","text":""},{"location":"#nomina.date_utils","title":"<code>date_utils</code>","text":"<p>Created on 2024-10-02</p> <p>@author: wf</p>"},{"location":"#nomina.date_utils.DateUtils","title":"<code>DateUtils</code>","text":"<p>date utilities</p> Source code in <code>nomina/date_utils.py</code> <pre><code>class DateUtils:\n    \"\"\"\n    date utilities\n    \"\"\"\n\n    @classmethod\n    def parse_date(\n        cls, date_str: str, date_formats: Optional[List[str]] = None\n    ) -&gt; Optional[str]:\n        \"\"\"\n        Parse the given date string using the provided formats.\n\n        Args:\n            date_str (str): The date string to parse.\n            date_formats (List[str], optional): List of date formats to try.\n                If None, uses a default list of formats.\n\n        Returns:\n            Optional[str]: The parsed date in ISO format (YYYY-MM-DD) or None if parsing fails.\n        \"\"\"\n        if date_formats is None:\n            date_formats = [\n                \"%m.%d.%y\",\n                \"%d.%m.%y\",\n                \"%m/%d/%y\",\n                \"%d/%m/%y\",\n                \"%Y-%m-%d\",\n                \"%Y/%m/%d\",\n                \"%Y-%m-%d %H:%M:%S %z\",  # Added to handle the GnuCash XML format\n            ]\n\n        for date_format in date_formats:\n            try:\n                date_obj = datetime.strptime(date_str, date_format)\n                return date_obj.strftime(\"%Y-%m-%d\")\n            except ValueError:\n                continue\n\n        return None\n\n    @classmethod\n    def split_date_range(\n        cls, start_date: str, end_date: str, num_ranges: int\n    ) -&gt; List[Tuple[str, str]]:\n        \"\"\"\n        Splits a date range into a predefined number of sub-ranges.\n\n        Args:\n            start_date (str): The start date in \"YYYY-MM-DD\" format.\n            end_date (str): The end date in \"YYYY-MM-DD\" format.\n            num_ranges (int): The number of ranges to split into.\n\n        Returns:\n            List[Tuple[str, str]]: A list of tuples representing the sub-ranges.\n        \"\"\"\n        start = datetime.strptime(start_date, \"%Y-%m-%d\")\n        end = datetime.strptime(end_date, \"%Y-%m-%d\")\n        total_days = (end - start).days\n\n        base_range_length = total_days // num_ranges\n        extra_days = total_days % num_ranges\n\n        ranges = []\n        current_start = start\n        for i in range(num_ranges):\n            range_length = base_range_length + (1 if i &lt; extra_days else 0)\n            current_end = current_start + timedelta(days=range_length - 1)\n\n            ranges.append(\n                (current_start.strftime(\"%Y-%m-%d\"), current_end.strftime(\"%Y-%m-%d\"))\n            )\n            current_start = current_end + timedelta(days=1)\n\n        # Ensure the last range ends on the specified end date\n        ranges[-1] = (ranges[-1][0], end_date)\n\n        return ranges\n</code></pre>"},{"location":"#nomina.date_utils.DateUtils.parse_date","title":"<code>parse_date(date_str, date_formats=None)</code>  <code>classmethod</code>","text":"<p>Parse the given date string using the provided formats.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>The date string to parse.</p> required <code>date_formats</code> <code>List[str]</code> <p>List of date formats to try. If None, uses a default list of formats.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The parsed date in ISO format (YYYY-MM-DD) or None if parsing fails.</p> Source code in <code>nomina/date_utils.py</code> <pre><code>@classmethod\ndef parse_date(\n    cls, date_str: str, date_formats: Optional[List[str]] = None\n) -&gt; Optional[str]:\n    \"\"\"\n    Parse the given date string using the provided formats.\n\n    Args:\n        date_str (str): The date string to parse.\n        date_formats (List[str], optional): List of date formats to try.\n            If None, uses a default list of formats.\n\n    Returns:\n        Optional[str]: The parsed date in ISO format (YYYY-MM-DD) or None if parsing fails.\n    \"\"\"\n    if date_formats is None:\n        date_formats = [\n            \"%m.%d.%y\",\n            \"%d.%m.%y\",\n            \"%m/%d/%y\",\n            \"%d/%m/%y\",\n            \"%Y-%m-%d\",\n            \"%Y/%m/%d\",\n            \"%Y-%m-%d %H:%M:%S %z\",  # Added to handle the GnuCash XML format\n        ]\n\n    for date_format in date_formats:\n        try:\n            date_obj = datetime.strptime(date_str, date_format)\n            return date_obj.strftime(\"%Y-%m-%d\")\n        except ValueError:\n            continue\n\n    return None\n</code></pre>"},{"location":"#nomina.date_utils.DateUtils.split_date_range","title":"<code>split_date_range(start_date, end_date, num_ranges)</code>  <code>classmethod</code>","text":"<p>Splits a date range into a predefined number of sub-ranges.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>The start date in \"YYYY-MM-DD\" format.</p> required <code>end_date</code> <code>str</code> <p>The end date in \"YYYY-MM-DD\" format.</p> required <code>num_ranges</code> <code>int</code> <p>The number of ranges to split into.</p> required <p>Returns:</p> Type Description <code>List[Tuple[str, str]]</code> <p>List[Tuple[str, str]]: A list of tuples representing the sub-ranges.</p> Source code in <code>nomina/date_utils.py</code> <pre><code>@classmethod\ndef split_date_range(\n    cls, start_date: str, end_date: str, num_ranges: int\n) -&gt; List[Tuple[str, str]]:\n    \"\"\"\n    Splits a date range into a predefined number of sub-ranges.\n\n    Args:\n        start_date (str): The start date in \"YYYY-MM-DD\" format.\n        end_date (str): The end date in \"YYYY-MM-DD\" format.\n        num_ranges (int): The number of ranges to split into.\n\n    Returns:\n        List[Tuple[str, str]]: A list of tuples representing the sub-ranges.\n    \"\"\"\n    start = datetime.strptime(start_date, \"%Y-%m-%d\")\n    end = datetime.strptime(end_date, \"%Y-%m-%d\")\n    total_days = (end - start).days\n\n    base_range_length = total_days // num_ranges\n    extra_days = total_days % num_ranges\n\n    ranges = []\n    current_start = start\n    for i in range(num_ranges):\n        range_length = base_range_length + (1 if i &lt; extra_days else 0)\n        current_end = current_start + timedelta(days=range_length - 1)\n\n        ranges.append(\n            (current_start.strftime(\"%Y-%m-%d\"), current_end.strftime(\"%Y-%m-%d\"))\n        )\n        current_start = current_end + timedelta(days=1)\n\n    # Ensure the last range ends on the specified end date\n    ranges[-1] = (ranges[-1][0], end_date)\n\n    return ranges\n</code></pre>"},{"location":"#nomina.gnucash","title":"<code>gnucash</code>","text":"<p>Created on 2024-10-02</p> <p>@author: wf</p>"},{"location":"#nomina.gnucash.GnuCashXml","title":"<code>GnuCashXml</code>","text":"<p>GnuCash XML reader/writer</p> Source code in <code>nomina/gnucash.py</code> <pre><code>class GnuCashXml:\n    \"\"\"\n    GnuCash XML reader/writer\n    \"\"\"\n\n    def __init__(self, indent: str = \"  \"):\n        \"\"\"\n        constructor\n        using two space indentation\n        \"\"\"\n        self.indent = indent\n        self.namespaces = {\n            \"gnc\": \"http://www.gnucash.org/XML/gnc\",\n            \"act\": \"http://www.gnucash.org/XML/act\",\n            \"book\": \"http://www.gnucash.org/XML/book\",\n            \"cd\": \"http://www.gnucash.org/XML/cd\",\n            \"cmdty\": \"http://www.gnucash.org/XML/cmdty\",\n            \"price\": \"http://www.gnucash.org/XML/price\",\n            \"slot\": \"http://www.gnucash.org/XML/slot\",\n            \"split\": \"http://www.gnucash.org/XML/split\",\n            \"sx\": \"http://www.gnucash.org/XML/sx\",\n            \"trn\": \"http://www.gnucash.org/XML/trn\",\n            \"ts\": \"http://www.gnucash.org/XML/ts\",\n            \"fs\": \"http://www.gnucash.org/XML/fs\",\n            \"bgt\": \"http://www.gnucash.org/XML/bgt\",\n            \"recurrence\": \"http://www.gnucash.org/XML/recurrence\",\n            \"lot\": \"http://www.gnucash.org/XML/lot\",\n            \"addr\": \"http://www.gnucash.org/XML/addr\",\n            \"billterm\": \"http://www.gnucash.org/XML/billterm\",\n            \"bt-days\": \"http://www.gnucash.org/XML/bt-days\",\n            \"bt-prox\": \"http://www.gnucash.org/XML/bt-prox\",\n            \"cust\": \"http://www.gnucash.org/XML/cust\",\n            \"employee\": \"http://www.gnucash.org/XML/employee\",\n            \"entry\": \"http://www.gnucash.org/XML/entry\",\n            \"invoice\": \"http://www.gnucash.org/XML/invoice\",\n            \"job\": \"http://www.gnucash.org/XML/job\",\n            \"order\": \"http://www.gnucash.org/XML/order\",\n            \"owner\": \"http://www.gnucash.org/XML/owner\",\n            \"taxtable\": \"http://www.gnucash.org/XML/taxtable\",\n            \"tte\": \"http://www.gnucash.org/XML/tte\",\n            \"vendor\": \"http://www.gnucash.org/XML/vendor\",\n        }\n\n    def parse_gnucash_xml(self, xml_file: str) -&gt; GncV2:\n        parser = XmlParser(config=ParserConfig(fail_on_unknown_properties=False))\n        return parser.parse(xml_file, GncV2)\n\n    def xml_format(self, xml_string: str) -&gt; str:\n        \"\"\"\n        adapt the format of the xml_string to gnu cash conventions\n        \"\"\"\n        # unindent two spaces twice\n        formatted_xml = re.sub(r\"(\\n  )\", r\"\\n\", xml_string)\n        formatted_xml = re.sub(r\"(\\n  )\", r\"\\n\", formatted_xml)\n\n        # formatting of xmlns attributes\n        xmlns_indent = \"     \"  # Five spaces\n        formatted_xml = re.sub(\n            r'\\s(xmlns:[^=]+=\"[^\"]+\")', f\"\\n{xmlns_indent}\\\\1\", formatted_xml\n        )\n\n        # Ensure there's a space before the closing ?&gt; in the XML declaration\n        formatted_xml = formatted_xml.replace(\"?&gt;\", \" ?&gt;\")\n\n        # Consistent empty element formatting\n        formatted_xml = re.sub(r\"&lt;([^&gt;]+)\\/&gt;\", r\"&lt;\\1/&gt;\", formatted_xml)\n\n        # add a new line at end\n        formatted_xml += \"\\n\"\n\n        return formatted_xml\n\n    def write_gnucash_xml(self, gnucash_data: GncV2, output_file: str) -&gt; None:\n        \"\"\"\n        Serialize the GnuCash data object to an XML file.\n\n        Args:\n            gnucash_data (GnuCashXml): The GnuCash data object to serialize.\n            output_file (str): The file path where the XML will be written.\n        \"\"\"\n        serializer = XmlSerializer(\n            config=SerializerConfig(\n                pretty_print=True,\n                xml_declaration=True,\n                encoding=\"utf-8\",\n                indent=self.indent,\n            )\n        )\n\n        with io.StringIO() as xml_buffer:\n            serializer.write(xml_buffer, gnucash_data, ns_map=self.namespaces)\n            xml_string = xml_buffer.getvalue()\n\n        # Apply the custom filter to the XML string\n        formatted_xml_string = self.xml_format(xml_string)\n\n        # Write the formatted XML string to the file\n        with open(output_file, \"w\", encoding=\"UTF-8\") as f:\n            f.write(formatted_xml_string)\n\n    def get_stats(self, gncv2: GncV2) -&gt; Dict:\n        dates = []\n        parse_errors = 0\n        for tx in gncv2.book.transactions:\n            if tx.date_posted and tx.date_posted.date:\n                parsed_date = DateUtils.parse_date(tx.date_posted.date)\n                if parsed_date:\n                    dates.append(datetime.strptime(parsed_date, \"%Y-%m-%d\"))\n                else:\n                    parse_errors += 1\n\n        if dates:\n            min_date = min(dates).strftime(\"%Y-%m-%d\")\n            max_date = max(dates).strftime(\"%Y-%m-%d\")\n        else:\n            min_date = max_date = None\n\n        return {\n            \"#transactions\": len(gncv2.book.transactions),\n            \"#accounts\": len(gncv2.book.accounts),\n            \"date_range\": {\"start_date\": min_date, \"end_date\": max_date},\n            \"parse_errors\": parse_errors,\n        }\n\n    def show_summary(self, gncv2: GncV2):\n        stats = self.get_stats(gncv2)\n        self.stats = stats\n        print(f\"#accounts: {stats['#accounts']}\")\n        print(f\"#transactions: {stats['#transactions']}\")\n        print(\n            f\"Date range: {stats['date_range']['start_date']} to {stats['date_range']['end_date']}\"\n        )\n</code></pre>"},{"location":"#nomina.gnucash.GnuCashXml.__init__","title":"<code>__init__(indent='  ')</code>","text":"<p>constructor using two space indentation</p> Source code in <code>nomina/gnucash.py</code> <pre><code>def __init__(self, indent: str = \"  \"):\n    \"\"\"\n    constructor\n    using two space indentation\n    \"\"\"\n    self.indent = indent\n    self.namespaces = {\n        \"gnc\": \"http://www.gnucash.org/XML/gnc\",\n        \"act\": \"http://www.gnucash.org/XML/act\",\n        \"book\": \"http://www.gnucash.org/XML/book\",\n        \"cd\": \"http://www.gnucash.org/XML/cd\",\n        \"cmdty\": \"http://www.gnucash.org/XML/cmdty\",\n        \"price\": \"http://www.gnucash.org/XML/price\",\n        \"slot\": \"http://www.gnucash.org/XML/slot\",\n        \"split\": \"http://www.gnucash.org/XML/split\",\n        \"sx\": \"http://www.gnucash.org/XML/sx\",\n        \"trn\": \"http://www.gnucash.org/XML/trn\",\n        \"ts\": \"http://www.gnucash.org/XML/ts\",\n        \"fs\": \"http://www.gnucash.org/XML/fs\",\n        \"bgt\": \"http://www.gnucash.org/XML/bgt\",\n        \"recurrence\": \"http://www.gnucash.org/XML/recurrence\",\n        \"lot\": \"http://www.gnucash.org/XML/lot\",\n        \"addr\": \"http://www.gnucash.org/XML/addr\",\n        \"billterm\": \"http://www.gnucash.org/XML/billterm\",\n        \"bt-days\": \"http://www.gnucash.org/XML/bt-days\",\n        \"bt-prox\": \"http://www.gnucash.org/XML/bt-prox\",\n        \"cust\": \"http://www.gnucash.org/XML/cust\",\n        \"employee\": \"http://www.gnucash.org/XML/employee\",\n        \"entry\": \"http://www.gnucash.org/XML/entry\",\n        \"invoice\": \"http://www.gnucash.org/XML/invoice\",\n        \"job\": \"http://www.gnucash.org/XML/job\",\n        \"order\": \"http://www.gnucash.org/XML/order\",\n        \"owner\": \"http://www.gnucash.org/XML/owner\",\n        \"taxtable\": \"http://www.gnucash.org/XML/taxtable\",\n        \"tte\": \"http://www.gnucash.org/XML/tte\",\n        \"vendor\": \"http://www.gnucash.org/XML/vendor\",\n    }\n</code></pre>"},{"location":"#nomina.gnucash.GnuCashXml.write_gnucash_xml","title":"<code>write_gnucash_xml(gnucash_data, output_file)</code>","text":"<p>Serialize the GnuCash data object to an XML file.</p> <p>Parameters:</p> Name Type Description Default <code>gnucash_data</code> <code>GnuCashXml</code> <p>The GnuCash data object to serialize.</p> required <code>output_file</code> <code>str</code> <p>The file path where the XML will be written.</p> required Source code in <code>nomina/gnucash.py</code> <pre><code>def write_gnucash_xml(self, gnucash_data: GncV2, output_file: str) -&gt; None:\n    \"\"\"\n    Serialize the GnuCash data object to an XML file.\n\n    Args:\n        gnucash_data (GnuCashXml): The GnuCash data object to serialize.\n        output_file (str): The file path where the XML will be written.\n    \"\"\"\n    serializer = XmlSerializer(\n        config=SerializerConfig(\n            pretty_print=True,\n            xml_declaration=True,\n            encoding=\"utf-8\",\n            indent=self.indent,\n        )\n    )\n\n    with io.StringIO() as xml_buffer:\n        serializer.write(xml_buffer, gnucash_data, ns_map=self.namespaces)\n        xml_string = xml_buffer.getvalue()\n\n    # Apply the custom filter to the XML string\n    formatted_xml_string = self.xml_format(xml_string)\n\n    # Write the formatted XML string to the file\n    with open(output_file, \"w\", encoding=\"UTF-8\") as f:\n        f.write(formatted_xml_string)\n</code></pre>"},{"location":"#nomina.gnucash.GnuCashXml.xml_format","title":"<code>xml_format(xml_string)</code>","text":"<p>adapt the format of the xml_string to gnu cash conventions</p> Source code in <code>nomina/gnucash.py</code> <pre><code>def xml_format(self, xml_string: str) -&gt; str:\n    \"\"\"\n    adapt the format of the xml_string to gnu cash conventions\n    \"\"\"\n    # unindent two spaces twice\n    formatted_xml = re.sub(r\"(\\n  )\", r\"\\n\", xml_string)\n    formatted_xml = re.sub(r\"(\\n  )\", r\"\\n\", formatted_xml)\n\n    # formatting of xmlns attributes\n    xmlns_indent = \"     \"  # Five spaces\n    formatted_xml = re.sub(\n        r'\\s(xmlns:[^=]+=\"[^\"]+\")', f\"\\n{xmlns_indent}\\\\1\", formatted_xml\n    )\n\n    # Ensure there's a space before the closing ?&gt; in the XML declaration\n    formatted_xml = formatted_xml.replace(\"?&gt;\", \" ?&gt;\")\n\n    # Consistent empty element formatting\n    formatted_xml = re.sub(r\"&lt;([^&gt;]+)\\/&gt;\", r\"&lt;\\1/&gt;\", formatted_xml)\n\n    # add a new line at end\n    formatted_xml += \"\\n\"\n\n    return formatted_xml\n</code></pre>"},{"location":"#nomina.gnucash.TsDate","title":"<code>TsDate</code>  <code>dataclass</code>","text":"Source code in <code>nomina/gnucash.py</code> <pre><code>@dataclass\nclass TsDate:\n    date: Optional[str] = field(\n        default=None,\n        metadata={\n            \"type\": \"Element\",\n            \"namespace\": \"http://www.gnucash.org/XML/ts\",\n        },\n    )\n\n    def __post_init__(self):\n        \"\"\"\n        format date to 1970-01-01 00:00:00 +0000\n        \"\"\"\n        if self.date and len(self.date)==10:\n            self.date += \" 00:00:00 +0000\"\n</code></pre>"},{"location":"#nomina.gnucash.TsDate.__post_init__","title":"<code>__post_init__()</code>","text":"<p>format date to 1970-01-01 00:00:00 +0000</p> Source code in <code>nomina/gnucash.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    format date to 1970-01-01 00:00:00 +0000\n    \"\"\"\n    if self.date and len(self.date)==10:\n        self.date += \" 00:00:00 +0000\"\n</code></pre>"},{"location":"#nomina.ledger","title":"<code>ledger</code>","text":"<p>Created on 04.10.2024</p> <p>@author: wf</p>"},{"location":"#nomina.ledger.Account","title":"<code>Account</code>","text":"<p>Represents a ledger account.</p> Source code in <code>nomina/ledger.py</code> <pre><code>@lod_storable\nclass Account:\n    \"\"\"\n    Represents a ledger account.\n    \"\"\"\n\n    account_id: str\n    name: str\n    account_type: str\n    description: Optional[str] = \"\"\n    currency: str = \"EUR\"  # Default to EUR\n    parent_account_id: Optional[str] = None\n</code></pre>"},{"location":"#nomina.ledger.Book","title":"<code>Book</code>","text":"<p>Represents a ledger book containing accounts and transactions.</p> Source code in <code>nomina/ledger.py</code> <pre><code>@lod_storable\nclass Book:\n    \"\"\"\n    Represents a ledger book containing accounts and transactions.\n    \"\"\"\n\n    name: Optional[str] = None\n    owner: Optional[str] = None\n    since: Optional[str] = None\n    url: Optional[str] = None\n    accounts: Dict[str, Account] = field(default_factory=dict)\n    transactions: Dict[str, Transaction] = field(default_factory=dict)\n\n    def __post_init__(self):\n        \"\"\"\n        post construct actions\n        \"\"\"\n\n    def get_stats(self) -&gt; Stats:\n        \"\"\"\n        Get statistics about the Book.\n\n        Returns:\n            Stats: An object containing various statistics about the Book.\n        \"\"\"\n        # Calculate date range\n        dates = [\n            datetime.strptime(tx.isodate.split()[0], \"%Y-%m-%d\")\n            for tx in self.transactions.values()\n            if tx.isodate\n        ]\n        if dates:\n            min_date = min(dates).strftime(\"%Y-%m-%d\")\n            max_date = max(dates).strftime(\"%Y-%m-%d\")\n        else:\n            min_date = max_date = None\n\n        return Stats(\n            accounts=len(self.accounts),\n            transactions=len(self.transactions),\n            start_date=min_date,\n            end_date=max_date\n        )\n\n\n    def filter(self, start_date: str = None, end_date: str = None) -&gt; \"Book\":\n        \"\"\"\n        Filter the transactions based on the given date range.\n\n        Args:\n            start_date (str): The start date in 'YYYY-MM-DD' format.\n            end_date (str): The end date in 'YYYY-MM-DD' format.\n\n        Returns:\n            Book: A new Book object with filtered transactions.\n        \"\"\"\n        filtered_transactions = {}\n\n        for transaction_id, transaction in self.transactions.items():\n            transaction_date = transaction.isodate.split()[\n                0\n            ]  # Extract 'YYYY-MM-DD' part\n\n            in_range = (not start_date or transaction_date &gt;= start_date) and (\n                not end_date or transaction_date &lt;= end_date\n            )\n\n            if in_range:\n                filtered_transactions[transaction_id] = transaction\n\n        filtered_book = deepcopy(self)\n        filtered_book.transactions = filtered_transactions\n        return filtered_book\n\n    def create_account(\n        self,\n        name: str,\n        account_type: str = \"EXPENSE\",\n        parent_account_id: Optional[str] = None,\n    ) -&gt; Account:\n        \"\"\"\n        Create a ledger account with the given parameters.\n\n        Args:\n            name (str): The name of the account.\n            account_type (str): The type of the account. Defaults to \"EXPENSE\".\n            parent_account_id (Optional[str]): The id of the parent account, if any.\n\n        Returns:\n            Account: A new Account object.\n        \"\"\"\n        # Calculate the account ID based on the parent's account ID (if any)\n        if parent_account_id:\n            parent_account = self.lookup_account(parent_account_id)\n            if parent_account:\n                account_id = f\"{parent_account_id}:{name}\"\n            else:\n                raise ValueError(f\"invalid parent account {parent_account_id}\")\n        else:\n            account_id = name  # top level account\n\n        # Create the account\n        account = Account(\n            account_id=account_id,\n            name=name,\n            account_type=account_type,\n            parent_account_id=parent_account_id,\n        )\n        self.add_account(account)\n\n    def add_account(self, account: Account):\n        \"\"\"\n        add the given account\n        \"\"\"\n        self.accounts[account.account_id] = account\n        return account\n\n    def lookup_account(self, account_id: str) -&gt; Optional[Account]:\n        \"\"\"\n        Get the account for the given account id.\n\n        Args:\n            account_id(str): The id of the account to look up.\n\n        Returns:\n            Optional[Account]: The found account or None if not found.\n        \"\"\"\n        return self.accounts.get(account_id)\n</code></pre>"},{"location":"#nomina.ledger.Book.__post_init__","title":"<code>__post_init__()</code>","text":"<p>post construct actions</p> Source code in <code>nomina/ledger.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    post construct actions\n    \"\"\"\n</code></pre>"},{"location":"#nomina.ledger.Book.add_account","title":"<code>add_account(account)</code>","text":"<p>add the given account</p> Source code in <code>nomina/ledger.py</code> <pre><code>def add_account(self, account: Account):\n    \"\"\"\n    add the given account\n    \"\"\"\n    self.accounts[account.account_id] = account\n    return account\n</code></pre>"},{"location":"#nomina.ledger.Book.create_account","title":"<code>create_account(name, account_type='EXPENSE', parent_account_id=None)</code>","text":"<p>Create a ledger account with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the account.</p> required <code>account_type</code> <code>str</code> <p>The type of the account. Defaults to \"EXPENSE\".</p> <code>'EXPENSE'</code> <code>parent_account_id</code> <code>Optional[str]</code> <p>The id of the parent account, if any.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Account</code> <code>Account</code> <p>A new Account object.</p> Source code in <code>nomina/ledger.py</code> <pre><code>def create_account(\n    self,\n    name: str,\n    account_type: str = \"EXPENSE\",\n    parent_account_id: Optional[str] = None,\n) -&gt; Account:\n    \"\"\"\n    Create a ledger account with the given parameters.\n\n    Args:\n        name (str): The name of the account.\n        account_type (str): The type of the account. Defaults to \"EXPENSE\".\n        parent_account_id (Optional[str]): The id of the parent account, if any.\n\n    Returns:\n        Account: A new Account object.\n    \"\"\"\n    # Calculate the account ID based on the parent's account ID (if any)\n    if parent_account_id:\n        parent_account = self.lookup_account(parent_account_id)\n        if parent_account:\n            account_id = f\"{parent_account_id}:{name}\"\n        else:\n            raise ValueError(f\"invalid parent account {parent_account_id}\")\n    else:\n        account_id = name  # top level account\n\n    # Create the account\n    account = Account(\n        account_id=account_id,\n        name=name,\n        account_type=account_type,\n        parent_account_id=parent_account_id,\n    )\n    self.add_account(account)\n</code></pre>"},{"location":"#nomina.ledger.Book.filter","title":"<code>filter(start_date=None, end_date=None)</code>","text":"<p>Filter the transactions based on the given date range.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>The start date in 'YYYY-MM-DD' format.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>The end date in 'YYYY-MM-DD' format.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Book</code> <code>Book</code> <p>A new Book object with filtered transactions.</p> Source code in <code>nomina/ledger.py</code> <pre><code>def filter(self, start_date: str = None, end_date: str = None) -&gt; \"Book\":\n    \"\"\"\n    Filter the transactions based on the given date range.\n\n    Args:\n        start_date (str): The start date in 'YYYY-MM-DD' format.\n        end_date (str): The end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        Book: A new Book object with filtered transactions.\n    \"\"\"\n    filtered_transactions = {}\n\n    for transaction_id, transaction in self.transactions.items():\n        transaction_date = transaction.isodate.split()[\n            0\n        ]  # Extract 'YYYY-MM-DD' part\n\n        in_range = (not start_date or transaction_date &gt;= start_date) and (\n            not end_date or transaction_date &lt;= end_date\n        )\n\n        if in_range:\n            filtered_transactions[transaction_id] = transaction\n\n    filtered_book = deepcopy(self)\n    filtered_book.transactions = filtered_transactions\n    return filtered_book\n</code></pre>"},{"location":"#nomina.ledger.Book.get_stats","title":"<code>get_stats()</code>","text":"<p>Get statistics about the Book.</p> <p>Returns:</p> Name Type Description <code>Stats</code> <code>Stats</code> <p>An object containing various statistics about the Book.</p> Source code in <code>nomina/ledger.py</code> <pre><code>def get_stats(self) -&gt; Stats:\n    \"\"\"\n    Get statistics about the Book.\n\n    Returns:\n        Stats: An object containing various statistics about the Book.\n    \"\"\"\n    # Calculate date range\n    dates = [\n        datetime.strptime(tx.isodate.split()[0], \"%Y-%m-%d\")\n        for tx in self.transactions.values()\n        if tx.isodate\n    ]\n    if dates:\n        min_date = min(dates).strftime(\"%Y-%m-%d\")\n        max_date = max(dates).strftime(\"%Y-%m-%d\")\n    else:\n        min_date = max_date = None\n\n    return Stats(\n        accounts=len(self.accounts),\n        transactions=len(self.transactions),\n        start_date=min_date,\n        end_date=max_date\n    )\n</code></pre>"},{"location":"#nomina.ledger.Book.lookup_account","title":"<code>lookup_account(account_id)</code>","text":"<p>Get the account for the given account id.</p> <p>Parameters:</p> Name Type Description Default <code>account_id(str)</code> <p>The id of the account to look up.</p> required <p>Returns:</p> Type Description <code>Optional[Account]</code> <p>Optional[Account]: The found account or None if not found.</p> Source code in <code>nomina/ledger.py</code> <pre><code>def lookup_account(self, account_id: str) -&gt; Optional[Account]:\n    \"\"\"\n    Get the account for the given account id.\n\n    Args:\n        account_id(str): The id of the account to look up.\n\n    Returns:\n        Optional[Account]: The found account or None if not found.\n    \"\"\"\n    return self.accounts.get(account_id)\n</code></pre>"},{"location":"#nomina.ledger.Split","title":"<code>Split</code>","text":"<p>Represents a split in a transaction.</p> Source code in <code>nomina/ledger.py</code> <pre><code>@lod_storable\nclass Split:\n    \"\"\"\n    Represents a split in a transaction.\n    \"\"\"\n\n    amount: float\n    account_id: str\n    memo: Optional[str] = \"\"\n    reconciled: bool = False\n</code></pre>"},{"location":"#nomina.ledger.Transaction","title":"<code>Transaction</code>","text":"<p>Represents a transaction in the ledger.</p> Source code in <code>nomina/ledger.py</code> <pre><code>@lod_storable\nclass Transaction:\n    \"\"\"\n    Represents a transaction in the ledger.\n    \"\"\"\n\n    isodate: str\n    description: str\n    splits: List[Split] = field(default_factory=list)\n    payee: Optional[str] = None\n    memo: Optional[str] = \"\"\n\n    def total_amount(self) -&gt; float:\n        \"\"\"\n        Calculates the total amount of the transaction.\n        Returns:\n            float: The sum of all split amounts.\n        \"\"\"\n        return sum(split.amount for split in self.splits)\n</code></pre>"},{"location":"#nomina.ledger.Transaction.total_amount","title":"<code>total_amount()</code>","text":"<p>Calculates the total amount of the transaction. Returns:     float: The sum of all split amounts.</p> Source code in <code>nomina/ledger.py</code> <pre><code>def total_amount(self) -&gt; float:\n    \"\"\"\n    Calculates the total amount of the transaction.\n    Returns:\n        float: The sum of all split amounts.\n    \"\"\"\n    return sum(split.amount for split in self.splits)\n</code></pre>"},{"location":"#nomina.nomina_cmd","title":"<code>nomina_cmd</code>","text":"<p>Created on 2024-10-06</p> <p>@author: wf</p>"},{"location":"#nomina.nomina_cmd.NominaCmd","title":"<code>NominaCmd</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>command line handling for nomina</p> Source code in <code>nomina/nomina_cmd.py</code> <pre><code>class NominaCmd(WebserverCmd):\n    \"\"\"\n    command line handling for nomina\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        config = NominaWebServer.get_config()\n        WebserverCmd.__init__(self, config, NominaWebServer, DEBUG)\n        pass\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        \"\"\"\n        override the default argparser call\n        \"\"\"\n        parser = super().getArgParser(description, version_msg)\n        parser.add_argument(\n            \"-v\",\n            \"--verbose\",\n            action=\"store_true\",\n            help=\"show verbose output [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-rp\",\n            \"--root_path\",\n            default=NominaWebServer.examples_path(),\n            help=\"path to nomina files [default: %(default)s]\",\n        )\n        return parser\n</code></pre>"},{"location":"#nomina.nomina_cmd.NominaCmd.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>nomina/nomina_cmd.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    config = NominaWebServer.get_config()\n    WebserverCmd.__init__(self, config, NominaWebServer, DEBUG)\n    pass\n</code></pre>"},{"location":"#nomina.nomina_cmd.NominaCmd.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>override the default argparser call</p> Source code in <code>nomina/nomina_cmd.py</code> <pre><code>def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n    \"\"\"\n    override the default argparser call\n    \"\"\"\n    parser = super().getArgParser(description, version_msg)\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"show verbose output [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-rp\",\n        \"--root_path\",\n        default=NominaWebServer.examples_path(),\n        help=\"path to nomina files [default: %(default)s]\",\n    )\n    return parser\n</code></pre>"},{"location":"#nomina.nomina_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>main call</p> Source code in <code>nomina/nomina_cmd.py</code> <pre><code>def main(argv: list = None):\n    \"\"\"\n    main call\n    \"\"\"\n    cmd = NominaCmd()\n    exit_code = cmd.cmd_main(argv)\n    return exit_code\n</code></pre>"},{"location":"#nomina.qif","title":"<code>qif</code>","text":"<p>Created on 2024-10-01</p> <p>Quicken Interchange Format (QIF) Parser see https://en.wikipedia.org/wiki/Quicken_Interchange_Format</p> <p>@author: wf</p>"},{"location":"#nomina.qif.Category","title":"<code>Category</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ParseRecord</code></p> <p>a QIF tag (Class or Category)</p> Source code in <code>nomina/qif.py</code> <pre><code>@lod_storable\nclass Category(ParseRecord):\n    \"\"\"\n    a QIF tag (Class or Category)\n    \"\"\"\n\n    name: Optional[str] = None\n    description: str = \"\"\n</code></pre>"},{"location":"#nomina.qif.QifClass","title":"<code>QifClass</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ParseRecord</code></p> <p>a QIF tag (Class or Category)</p> Source code in <code>nomina/qif.py</code> <pre><code>@lod_storable\nclass QifClass(ParseRecord):\n    \"\"\"\n    a QIF tag (Class or Category)\n    \"\"\"\n\n    name: Optional[str] = None\n    description: str = \"\"\n</code></pre>"},{"location":"#nomina.qif.SimpleQifParser","title":"<code>SimpleQifParser</code>","text":"<p>a QIF parser</p> Source code in <code>nomina/qif.py</code> <pre><code>@lod_storable\nclass SimpleQifParser:\n    \"\"\"\n    a QIF parser\n    \"\"\"\n\n    currency: str = \"EUR\"\n    default_account_type = \"EXPENSE\"\n    options: Dict[str, str] = field(default_factory=dict)\n    classes: Dict[str, QifClass] = field(default_factory=dict)\n    categories: Dict[str, Category] = field(default_factory=dict)\n    accounts: Dict[str, Account] = field(default_factory=dict)\n    transactions: Dict[str, Transaction] = field(default_factory=dict)\n    accounts: Dict[str, Account] = field(default_factory=dict)\n    errors: List[ErrorRecord] = field(default_factory=list)\n\n    def __post_init__(self):\n        self.current_account = None\n        self.field_names = {\n            \"$\": \"split_amount\",\n            \"~\": \"~?\",\n            \"&amp;\": \"&amp;?\",\n            \"%\": \"%?\",\n            \"@\": \"@?\",\n            \"A\": \"address\",\n            \"B\": \"B?\",\n            \"C\": \"cleared\",\n            \"D\": \"isodate\",\n            \"E\": \"split_memo\",\n            \"F\": \"F?\",\n            \"G\": \"G?\",\n            \"I\": \"I?\",\n            \"K\": \"K?\",\n            \"L\": \"category\",\n            \"M\": \"memo\",\n            \"N\": \"name\",\n            \"O\": \"O?\",\n            \"R\": \"R?\",\n            \"P\": \"payee\",\n            \"Q\": \"Q?\",\n            \"S\": \"split_category\",\n            \"T\": \"amount\",\n            \"U\": \"amount_unknown\",\n            \"V\": \"V?\",\n            \"Y\": \"Y?\",\n        }\n\n    def parse_file(\n        self,\n        qif_file: str,\n        encoding=\"iso-8859-1\",\n        verbose: bool = False,\n        debug: bool = False,\n    ):\n        \"\"\"\n        parse a qif file\n\n        Args:\n            qif_file (str): Path to the input QIF file.\n            encoding (str): File encoding. Defaults to 'iso-8859-1'.\n            verbose (bool): if True give verbose output\n            debug (bool): if True show debug output\n        \"\"\"\n        with open(qif_file, \"r\", encoding=encoding) as file:\n            content = file.readlines()\n        self.parse(content, verbose=verbose, debug=debug)\n\n    def parse(self, lines: List[str], verbose: bool = False, debug: bool = False):\n        \"\"\"\n        parse the given list of lines\n        \"\"\"\n        current_record = {}\n        record_type = None\n        start_line = 1\n\n        for line_num, line in enumerate(lines, 1):\n            line = line.strip()\n            if not line:\n                continue\n            if debug:\n                print(f\"{line_num}:{line}\")\n            if line.startswith(\"$\"):\n                self.currency = \"USD\"\n            elif line.startswith(\"\u20ac\"):\n                self.currency = \"EUR\"\n            if line.startswith(\"!Option:\"):\n                option = line[8:]\n                self.options[option] = True\n            elif line.startswith(\"!Clear:\"):\n                option = line[8:]\n                self.options[option] = False\n            elif line.startswith(\"!Type:\") or line.startswith(\"!Account\"):\n                if current_record:\n                    self._add_record(\n                        record_type, current_record, start_line, line_num - 1\n                    )\n                if line.startswith(\"!Account\"):\n                    record_type = \"Account\"\n                else:\n                    record_type = line[6:]  # Text after !Type:\n                    pass\n                current_record = {}\n                start_line = line_num + 1\n            elif line == \"^\":\n                if current_record:\n                    self._add_record(record_type, current_record, start_line, line_num)\n                current_record = {}\n                start_line = line_num + 1\n\n            elif line[0] in self.field_names:\n                first = line[0]\n                key = self.field_names.get(first)\n                value = line[1:].strip()\n                if key in [\"split_category\", \"split_memo\", \"split_amount\"]:\n                    if key not in current_record:\n                        current_record[key] = []\n                    current_record[key].append(value)\n                else:\n                    current_record[key] = value\n            else:\n                error = ErrorRecord(start_line=start_line, end_line=line_num, line=line)\n                err_msg = f\"parser can not handle line {line_num}: {line}\"\n                if verbose or debug:\n                    logging.error(err_msg)\n                self.errors.append(error)\n\n        if current_record:\n            self._add_record(record_type, current_record, start_line, len(lines))\n\n    def _add_account(\n        self,\n        account_name: str,\n        account_type: str,\n        description: str,\n        start_line,\n        end_line,\n    ) -&gt; Account:\n        \"\"\"\n        add an account for the given parameters making sure the parent account is created if need be\n        \"\"\"\n        parts = account_name.split(\":\")\n        name = parts[-1]\n        parent_name = \":\".join(parts[:-1]) if len(parts) &gt; 1 else None\n        parent_id = parent_name\n        if account_type is None:\n            account_type = self.default_account_type\n        if parent_name and parent_name not in self.accounts:\n            self.accounts[parent_name] = Account(\n                name=parent_name,\n                account_type=account_type,\n                currency=self.currency,\n                start_line=start_line,\n                end_line=end_line,\n            )\n        account = Account(\n            name=name,\n            description=description,\n            account_type=account_type,\n            currency=self.currency,\n            parent_account_id=parent_id,\n            start_line=start_line,\n            end_line=end_line,\n        )\n        self.accounts[account.name] = account\n        return account\n\n    def _add_record(\n        self, record_type: str, record: Dict[str, Any], start_line: int, end_line: int\n    ):\n        \"\"\"\n        add the given record\n        \"\"\"\n        record[\"_start_line\"] = start_line\n        record[\"_end_line\"] = end_line\n        if record_type == \"Account\":\n            # @TODO allow external lookup of currency since quicken does not have it\n            # Determine if the account has a parent by checking for a ':' in the name\n            account_name = record.get(\"name\", \"\")\n            account_type = account_type = record.get(\"account_type\")\n            description = record.get(\"description\", \"\")\n            self.current_account = self._add_account(\n                account_name,\n                account_type=account_type,\n                description=description,\n                start_line=start_line,\n                end_line=end_line,\n            )\n        elif record_type == \"Class\":\n            qclass = QifClass(\n                name=record.get(\"name\", \"\"),\n                description=record.get(\"description\", \"\"),\n                start_line=start_line,\n                end_line=end_line,\n            )\n            self.classes[qclass.name] = qclass\n        elif record_type == \"Cat\":\n            cat = Category(\n                name=record.get(\"name\", \"\"),\n                description=record.get(\"description\", \"\"),\n                start_line=start_line,\n                end_line=end_line,\n            )\n            self.categories[cat.name] = cat\n        else:\n            tx = self.tx_for_record(record)\n            if self.current_account:\n                tx.account = self.current_account\n                account_name = self.current_account.name\n                tx_id = f\"{account_name}:{tx.isodate}:{tx.start_line}\"\n            else:\n                tx_id = f\"{tx.isodate}:{tx.start_line}\"\n\n            self.transactions[tx_id] = tx\n\n    def tx_for_record(self, t):\n        \"\"\"\n        convert the transaction record\n        \"\"\"\n        transaction = Transaction(start_line=t[\"_start_line\"], end_line=t[\"_end_line\"])\n\n        for key, value in t.items():\n            if key.startswith(\"_\"):\n                continue\n            setattr(transaction, key, value)\n        transaction.normalize()\n        return transaction\n\n    def get_lod(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get a list of dictionaries representing all transactions.\n\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries, each representing a transaction.\n        \"\"\"\n        lod = []\n        for tx in self.transactions.values():\n            record = {\n                # \"tx_id\": f\"{self.current_account.name}:{tx.isodate}:{tx.start_line}\",\n                # \"account\": self.current_account.name,\n                \"isodate\": tx.isodate,\n                \"amount\": tx.amount,\n                \"payee\": tx.payee,\n                \"memo\": tx.memo,\n                \"category\": tx.category,\n                \"number\": tx.number,\n                \"cleared\": tx.cleared,\n                \"address\": tx.address,\n                \"split_category\": (\n                    \",\".join(tx.split_category) if tx.split_category else None\n                ),\n                \"split_memo\": \",\".join(tx.split_memo) if tx.split_memo else None,\n                \"split_amount\": (\n                    \",\".join(map(str, tx.split_amount)) if tx.split_amount else None\n                ),\n                \"qif_class\": tx.qif_class.name if tx.qif_class else None,\n            }\n            lod.append(record)\n        return lod\n\n    def print_sample_transactions(self, num_samples: int = 7):\n        print(f\"\\nSample of {min(num_samples, len(self.transactions))} transactions:\")\n        txs = list(self.transactions.values())[:num_samples]\n        for idx, transaction in enumerate(txs, 1):\n            print(\n                f\"Transaction {idx} (lines {transaction.start_line}-{transaction.end_line}):\"\n            )\n            for field, value in vars(transaction).items():\n                if field not in [\"start_line\", \"end_line\", \"errors\"]:\n                    if isinstance(value, list):\n                        print(f\"  {field}: {', '.join(map(str, value))}\")\n                    else:\n                        print(f\"  {field}: {value}\")\n            if transaction.errors:\n                print(\"  Errors:\")\n                for field, error in transaction.errors.items():\n                    print(f\"    {field}: {type(error).__name__}: {str(error)}\")\n            print()\n\n    def print_parts(self, parts: dict, title: str, limit: int = 100000):\n        print(f\"\\n{title}:\")\n        for i, part in enumerate(parts.values(), start=1):\n            if i &gt;= limit:\n                break\n            print(\n                f\"{i:3}: {part.name} - {part.description} (#{part.start_line}-{part.end_line})\"\n            )\n\n    def get_stats(self) -&gt; Stats:\n        dates = [\n            datetime.strptime(tx.isodate, \"%Y-%m-%d\")\n            for tx in self.transactions.values()\n            if tx.isodate\n        ]\n        if dates:\n            min_date = min(dates).strftime(\"%Y-%m-%d\")\n            max_date = max(dates).strftime(\"%Y-%m-%d\")\n        else:\n            min_date = max_date = None\n\n        other_stats = {\n            \"options\": self.options,\n            \"field_histogram\": self._get_field_histogram(),\n            \"error_histogram\": self._get_error_histogram(),\n        }\n\n        return Stats(\n            accounts=len(self.accounts),\n            transactions=len(self.transactions),\n            start_date=min_date,\n            end_date=max_date,\n            classes=len(self.classes),\n            categories=len(self.categories),\n            errors=len(self.errors),\n            other=other_stats\n        )\n\n\n    def _get_field_histogram(self) -&gt; Dict[str, int]:\n        field_counter = Counter()\n        for transaction in self.transactions.values():\n            for field, value in vars(transaction).items():\n                if field not in [\"start_line\", \"end_line\", \"errors\"]:\n                    if value is not None and (\n                        not isinstance(value, list) or len(value) &gt; 0\n                    ):\n                        field_counter[field] += 1\n        return dict(field_counter)\n\n    def _get_error_histogram(self) -&gt; Dict[str, int]:\n        error_counter = Counter()\n        for transaction in self.transactions.values():\n            error_counter.update(transaction.errors.keys())\n        return dict(error_counter)\n\n    def generate_error_report(self, max_errors_per_type=10):\n        \"\"\"\n        Generate a detailed error report.\n\n        Args:\n            max_errors_per_type (int): Maximum number of errors to show for each error type.\n\n        Returns:\n            str: A formatted error report.\n        \"\"\"\n        error_types = {}\n        for transaction in self.transactions.values():\n            for field, error in transaction.errors.items():\n                error_type = type(error).__name__\n                if error_type not in error_types:\n                    error_types[error_type] = []\n                error_types[error_type].append((transaction, field, error))\n\n        report = [\"Detailed Error Report:\"]\n        for error_type, errors in error_types.items():\n            report.append(f\"\\n{error_type} ({len(errors)} occurrences):\")\n            for i, (transaction, field, error) in enumerate(\n                errors[:max_errors_per_type], 1\n            ):\n                report.append(\n                    f\"  {i}. Line {transaction.start_line}-{transaction.end_line}, Field: {field}\"\n                )\n                report.append(f\"     Error: {str(error)}\")\n                report.append(\n                    f\"     Transaction: {self.transaction_summary(transaction)}\"\n                )\n            if len(errors) &gt; max_errors_per_type:\n                report.append(f\"  ... and {len(errors) - max_errors_per_type} more.\")\n\n        return \"\\n\".join(report)\n\n    def transaction_summary(self, transaction):\n        \"\"\"Helper function to provide a summary of a transaction.\"\"\"\n        summary = []\n        for field, value in vars(transaction).items():\n            if field not in [\"start_line\", \"end_line\", \"errors\"] and value is not None:\n                summary.append(f\"{field}: {value}\")\n        return \", \".join(summary)\n\n    def show_summary(self, limit: int = 7):\n        stats = self.get_stats()\n        self.stats = stats\n\n        # Display basic statistics\n        print(f\"Options: {stats.other.get('options', {})}\")\n        print(f\"#classes: {stats.classes}\")\n        print(f\"#categories: {stats.categories}\")\n        print(f\"#accounts: {stats.accounts}\")\n        print(f\"#transactions: {stats.transactions}\")\n        print(f\"#errors: {stats.errors}\")\n        print(f\"Date range: {stats.start_date} to {stats.end_date}\")\n\n        # Display field and error histograms\n        print(\"Field histogram:\")\n        field_histogram = stats.other.get('field_histogram', {})\n        for field, count in field_histogram.items():\n            print(f\"  {field}: {count}\")\n\n        print(\"Error histogram:\")\n        error_histogram = stats.other.get('error_histogram', {})\n        for field, count in error_histogram.items():\n            print(f\"  {field}: {count}\")\n\n        # Display parts\n        self.print_parts(self.accounts, \"Accounts\", limit=limit)\n        self.print_parts(self.classes, \"Classes\", limit=limit)\n        self.print_parts(self.categories, \"Categories\", limit=limit)\n\n        # Display sample transactions\n        print(\"\\nSample Transactions:\")\n        self.print_sample_transactions()\n\n        # Generate and display error report\n        error_report = self.generate_error_report()\n        print(error_report)\n</code></pre>"},{"location":"#nomina.qif.SimpleQifParser.generate_error_report","title":"<code>generate_error_report(max_errors_per_type=10)</code>","text":"<p>Generate a detailed error report.</p> <p>Parameters:</p> Name Type Description Default <code>max_errors_per_type</code> <code>int</code> <p>Maximum number of errors to show for each error type.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>str</code> <p>A formatted error report.</p> Source code in <code>nomina/qif.py</code> <pre><code>def generate_error_report(self, max_errors_per_type=10):\n    \"\"\"\n    Generate a detailed error report.\n\n    Args:\n        max_errors_per_type (int): Maximum number of errors to show for each error type.\n\n    Returns:\n        str: A formatted error report.\n    \"\"\"\n    error_types = {}\n    for transaction in self.transactions.values():\n        for field, error in transaction.errors.items():\n            error_type = type(error).__name__\n            if error_type not in error_types:\n                error_types[error_type] = []\n            error_types[error_type].append((transaction, field, error))\n\n    report = [\"Detailed Error Report:\"]\n    for error_type, errors in error_types.items():\n        report.append(f\"\\n{error_type} ({len(errors)} occurrences):\")\n        for i, (transaction, field, error) in enumerate(\n            errors[:max_errors_per_type], 1\n        ):\n            report.append(\n                f\"  {i}. Line {transaction.start_line}-{transaction.end_line}, Field: {field}\"\n            )\n            report.append(f\"     Error: {str(error)}\")\n            report.append(\n                f\"     Transaction: {self.transaction_summary(transaction)}\"\n            )\n        if len(errors) &gt; max_errors_per_type:\n            report.append(f\"  ... and {len(errors) - max_errors_per_type} more.\")\n\n    return \"\\n\".join(report)\n</code></pre>"},{"location":"#nomina.qif.SimpleQifParser.get_lod","title":"<code>get_lod()</code>","text":"<p>Get a list of dictionaries representing all transactions.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries, each representing a transaction.</p> Source code in <code>nomina/qif.py</code> <pre><code>def get_lod(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get a list of dictionaries representing all transactions.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries, each representing a transaction.\n    \"\"\"\n    lod = []\n    for tx in self.transactions.values():\n        record = {\n            # \"tx_id\": f\"{self.current_account.name}:{tx.isodate}:{tx.start_line}\",\n            # \"account\": self.current_account.name,\n            \"isodate\": tx.isodate,\n            \"amount\": tx.amount,\n            \"payee\": tx.payee,\n            \"memo\": tx.memo,\n            \"category\": tx.category,\n            \"number\": tx.number,\n            \"cleared\": tx.cleared,\n            \"address\": tx.address,\n            \"split_category\": (\n                \",\".join(tx.split_category) if tx.split_category else None\n            ),\n            \"split_memo\": \",\".join(tx.split_memo) if tx.split_memo else None,\n            \"split_amount\": (\n                \",\".join(map(str, tx.split_amount)) if tx.split_amount else None\n            ),\n            \"qif_class\": tx.qif_class.name if tx.qif_class else None,\n        }\n        lod.append(record)\n    return lod\n</code></pre>"},{"location":"#nomina.qif.SimpleQifParser.parse","title":"<code>parse(lines, verbose=False, debug=False)</code>","text":"<p>parse the given list of lines</p> Source code in <code>nomina/qif.py</code> <pre><code>def parse(self, lines: List[str], verbose: bool = False, debug: bool = False):\n    \"\"\"\n    parse the given list of lines\n    \"\"\"\n    current_record = {}\n    record_type = None\n    start_line = 1\n\n    for line_num, line in enumerate(lines, 1):\n        line = line.strip()\n        if not line:\n            continue\n        if debug:\n            print(f\"{line_num}:{line}\")\n        if line.startswith(\"$\"):\n            self.currency = \"USD\"\n        elif line.startswith(\"\u20ac\"):\n            self.currency = \"EUR\"\n        if line.startswith(\"!Option:\"):\n            option = line[8:]\n            self.options[option] = True\n        elif line.startswith(\"!Clear:\"):\n            option = line[8:]\n            self.options[option] = False\n        elif line.startswith(\"!Type:\") or line.startswith(\"!Account\"):\n            if current_record:\n                self._add_record(\n                    record_type, current_record, start_line, line_num - 1\n                )\n            if line.startswith(\"!Account\"):\n                record_type = \"Account\"\n            else:\n                record_type = line[6:]  # Text after !Type:\n                pass\n            current_record = {}\n            start_line = line_num + 1\n        elif line == \"^\":\n            if current_record:\n                self._add_record(record_type, current_record, start_line, line_num)\n            current_record = {}\n            start_line = line_num + 1\n\n        elif line[0] in self.field_names:\n            first = line[0]\n            key = self.field_names.get(first)\n            value = line[1:].strip()\n            if key in [\"split_category\", \"split_memo\", \"split_amount\"]:\n                if key not in current_record:\n                    current_record[key] = []\n                current_record[key].append(value)\n            else:\n                current_record[key] = value\n        else:\n            error = ErrorRecord(start_line=start_line, end_line=line_num, line=line)\n            err_msg = f\"parser can not handle line {line_num}: {line}\"\n            if verbose or debug:\n                logging.error(err_msg)\n            self.errors.append(error)\n\n    if current_record:\n        self._add_record(record_type, current_record, start_line, len(lines))\n</code></pre>"},{"location":"#nomina.qif.SimpleQifParser.parse_file","title":"<code>parse_file(qif_file, encoding='iso-8859-1', verbose=False, debug=False)</code>","text":"<p>parse a qif file</p> <p>Parameters:</p> Name Type Description Default <code>qif_file</code> <code>str</code> <p>Path to the input QIF file.</p> required <code>encoding</code> <code>str</code> <p>File encoding. Defaults to 'iso-8859-1'.</p> <code>'iso-8859-1'</code> <code>verbose</code> <code>bool</code> <p>if True give verbose output</p> <code>False</code> <code>debug</code> <code>bool</code> <p>if True show debug output</p> <code>False</code> Source code in <code>nomina/qif.py</code> <pre><code>def parse_file(\n    self,\n    qif_file: str,\n    encoding=\"iso-8859-1\",\n    verbose: bool = False,\n    debug: bool = False,\n):\n    \"\"\"\n    parse a qif file\n\n    Args:\n        qif_file (str): Path to the input QIF file.\n        encoding (str): File encoding. Defaults to 'iso-8859-1'.\n        verbose (bool): if True give verbose output\n        debug (bool): if True show debug output\n    \"\"\"\n    with open(qif_file, \"r\", encoding=encoding) as file:\n        content = file.readlines()\n    self.parse(content, verbose=verbose, debug=debug)\n</code></pre>"},{"location":"#nomina.qif.SimpleQifParser.transaction_summary","title":"<code>transaction_summary(transaction)</code>","text":"<p>Helper function to provide a summary of a transaction.</p> Source code in <code>nomina/qif.py</code> <pre><code>def transaction_summary(self, transaction):\n    \"\"\"Helper function to provide a summary of a transaction.\"\"\"\n    summary = []\n    for field, value in vars(transaction).items():\n        if field not in [\"start_line\", \"end_line\", \"errors\"] and value is not None:\n            summary.append(f\"{field}: {value}\")\n    return \", \".join(summary)\n</code></pre>"},{"location":"#nomina.qif.SimpleQifParser.tx_for_record","title":"<code>tx_for_record(t)</code>","text":"<p>convert the transaction record</p> Source code in <code>nomina/qif.py</code> <pre><code>def tx_for_record(self, t):\n    \"\"\"\n    convert the transaction record\n    \"\"\"\n    transaction = Transaction(start_line=t[\"_start_line\"], end_line=t[\"_end_line\"])\n\n    for key, value in t.items():\n        if key.startswith(\"_\"):\n            continue\n        setattr(transaction, key, value)\n    transaction.normalize()\n    return transaction\n</code></pre>"},{"location":"#nomina.qif.Transaction","title":"<code>Transaction</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ParseRecord</code></p> <p>a single transaction</p> Source code in <code>nomina/qif.py</code> <pre><code>@lod_storable\nclass Transaction(ParseRecord):\n    \"\"\"\n    a single transaction\n    \"\"\"\n\n    isodate: Optional[str] = None\n    amount: Optional[str] = None\n    payee: Optional[str] = None\n    memo: Optional[str] = None\n    category: Optional[str] = None\n    number: Optional[str] = None\n    cleared: Optional[str] = None\n    address: Optional[str] = None\n    split_category: List[str] = field(default_factory=list)\n    split_memo: List[str] = field(default_factory=list)\n    split_amount: List[str] = field(default_factory=list)\n    account: Optional[Account] = None\n    qif_class: Optional[QifClass] = None\n    category: Optional[Category] = None\n\n    def __post_init__(self):\n        self.amount_float: Optional[float] = None\n        self.split_amounts_float: List[float] = []\n        self.normalize()\n        pass\n\n    def normalize(self):\n        \"\"\"\n        Normalize the transaction data, converting string amounts to floats.\n        \"\"\"\n        try:\n            if self.isodate:\n                self.isodate = DateUtils.parse_date(self.isodate)\n        except Exception as ex:\n            self.errors[\"date\"] = ex\n\n        try:\n            if self.amount:\n                self.amount_float = self.parse_amount(self.amount)\n        except Exception as ex:\n            self.errors[\"amount\"] = ex\n\n        self.split_amounts_float = []\n        for i, amount in enumerate(self.split_amount):\n            try:\n                self.split_amounts_float.append(self.parse_amount(amount))\n            except Exception as ex:\n                self.errors[f\"split{i}\"].append(ex)\n\n    def parse_amount(self, amount_str: str) -&gt; float:\n        # Remove any currency symbols and whitespace\n        cleaned_str = re.sub(r\"[^\\d,.-]\", \"\", amount_str)\n        # Replace comma with dot if comma is used as decimal separator\n        if \",\" in cleaned_str and \".\" not in cleaned_str:\n            cleaned_str = cleaned_str.replace(\",\", \".\")\n        elif \",\" in cleaned_str and \".\" in cleaned_str:\n            cleaned_str = cleaned_str.replace(\",\", \"\")\n        try:\n            return float(cleaned_str)\n        except ValueError:\n            raise ValueError(f\"Unable to parse amount: {amount_str}\")\n\n    def total_split_amount(self) -&gt; float:\n        \"\"\"\n        Calculate the total amount for split transactions.\n\n        Returns:\n            float: The sum of all split amounts.\n        \"\"\"\n        return sum(self.split_amounts_float)\n</code></pre>"},{"location":"#nomina.qif.Transaction.normalize","title":"<code>normalize()</code>","text":"<p>Normalize the transaction data, converting string amounts to floats.</p> Source code in <code>nomina/qif.py</code> <pre><code>def normalize(self):\n    \"\"\"\n    Normalize the transaction data, converting string amounts to floats.\n    \"\"\"\n    try:\n        if self.isodate:\n            self.isodate = DateUtils.parse_date(self.isodate)\n    except Exception as ex:\n        self.errors[\"date\"] = ex\n\n    try:\n        if self.amount:\n            self.amount_float = self.parse_amount(self.amount)\n    except Exception as ex:\n        self.errors[\"amount\"] = ex\n\n    self.split_amounts_float = []\n    for i, amount in enumerate(self.split_amount):\n        try:\n            self.split_amounts_float.append(self.parse_amount(amount))\n        except Exception as ex:\n            self.errors[f\"split{i}\"].append(ex)\n</code></pre>"},{"location":"#nomina.qif.Transaction.total_split_amount","title":"<code>total_split_amount()</code>","text":"<p>Calculate the total amount for split transactions.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The sum of all split amounts.</p> Source code in <code>nomina/qif.py</code> <pre><code>def total_split_amount(self) -&gt; float:\n    \"\"\"\n    Calculate the total amount for split transactions.\n\n    Returns:\n        float: The sum of all split amounts.\n    \"\"\"\n    return sum(self.split_amounts_float)\n</code></pre>"},{"location":"#nomina.stats","title":"<code>stats</code>","text":"<p>Created on 2024-10-06</p> <p>@author: wf</p>"},{"location":"#nomina.stats.Stats","title":"<code>Stats</code>","text":"<p>Ledger statistics</p> Source code in <code>nomina/stats.py</code> <pre><code>@lod_storable\nclass Stats:\n    \"\"\"\n    Ledger statistics\n    \"\"\"\n    accounts: int\n    transactions: int\n    start_date: Optional[str] = None\n    end_date: Optional[str] = None\n    classes: Optional[int] = None\n    categories: Optional[int] = None\n    errors: Optional[int] = None\n    other: Optional[Dict[str, Any]] = field(default_factory=dict)\n</code></pre>"},{"location":"#nomina.version","title":"<code>version</code>","text":"<p>Created on 2024-10-06 @author: wf</p>"},{"location":"#nomina.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for MoneyBrowser</p> Source code in <code>nomina/version.py</code> <pre><code>@dataclass\nclass Version(object):\n    \"\"\"\n    Version handling for MoneyBrowser\n    \"\"\"\n    name = \"pynomina\"\n    version = \"0.0.1\"\n    date = \"2024-10-06\"\n    updated = \"2024-10-06\"\n    description = \"Personal finance tool\"\n    authors = \"Wolfgang Fahl\"\n\n    doc_url = \"https://wiki.bitplan.com/index.php/Pynomina\"\n    chat_url = \"https://github.com/WolfgangFahl/pynomina/discussions/\"\n    cm_url = \"https://github.com/WolfgangFahl/pynomina\"\n\n    license = f\"\"\"Copyright 2024 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#nomina.webserver","title":"<code>webserver</code>","text":"<p>Created on 2024-10-06</p> <p>@author: wf</p>"},{"location":"#nomina.webserver.NominaSolution","title":"<code>NominaSolution</code>","text":"<p>               Bases: <code>InputWebSolution</code></p> <p>the Nomina solution</p> Source code in <code>nomina/webserver.py</code> <pre><code>class NominaSolution(InputWebSolution):\n    \"\"\"\n    the Nomina solution\n    \"\"\"\n\n    def __init__(self, webserver: NominaWebServer, client: Client):\n        \"\"\"\n        Initialize the solution\n\n        Calls the constructor of the base solution\n        Args:\n            webserver (NiceScadWebServer): The webserver instance associated with this context.\n            client (Client): The client instance this context is associated with.\n        \"\"\"\n        super().__init__(webserver, client)  # Call to the superclass constructor\n</code></pre>"},{"location":"#nomina.webserver.NominaSolution.__init__","title":"<code>__init__(webserver, client)</code>","text":"<p>Initialize the solution</p> <p>Calls the constructor of the base solution Args:     webserver (NiceScadWebServer): The webserver instance associated with this context.     client (Client): The client instance this context is associated with.</p> Source code in <code>nomina/webserver.py</code> <pre><code>def __init__(self, webserver: NominaWebServer, client: Client):\n    \"\"\"\n    Initialize the solution\n\n    Calls the constructor of the base solution\n    Args:\n        webserver (NiceScadWebServer): The webserver instance associated with this context.\n        client (Client): The client instance this context is associated with.\n    \"\"\"\n    super().__init__(webserver, client)  # Call to the superclass constructor\n</code></pre>"},{"location":"#nomina.webserver.NominaWebServer","title":"<code>NominaWebServer</code>","text":"<p>               Bases: <code>InputWebserver</code></p> <p>Nomina Webserver</p> Source code in <code>nomina/webserver.py</code> <pre><code>class NominaWebServer(InputWebserver):\n    \"\"\"\n    Nomina Webserver\n    \"\"\"\n\n    @classmethod\n    def get_config(cls) -&gt; WebserverConfig:\n        copy_right = \"(c)2024 Wolfgang Fahl\"\n        config = WebserverConfig(\n            copy_right=copy_right,\n            version=Version(),\n            default_port=9849,\n            short_name=\"nomina\",\n        )\n        server_config = WebserverConfig.get(config)\n        server_config.solution_class = NominaSolution\n        return server_config\n\n    def __init__(self):\n        \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n        InputWebserver.__init__(self, config=NominaWebServer.get_config())\n\n    def configure_run(self):\n        root_path = (\n            self.args.root_path\n            if self.args.root_path\n            else NominaWebServer.examples_path()\n        )\n        self.root_path = os.path.abspath(root_path)\n        self.allowed_urls = [\n            self.examples_path(),\n            self.root_path,\n        ]\n\n    @classmethod\n    def examples_path(cls) -&gt; str:\n        # the root directory (default: examples)\n        path = os.path.join(os.path.dirname(__file__), \"../nomina_examples\")\n        path = os.path.abspath(path)\n        return path\n</code></pre>"},{"location":"#nomina.webserver.NominaWebServer.__init__","title":"<code>__init__()</code>","text":"<p>Constructs all the necessary attributes for the WebServer object.</p> Source code in <code>nomina/webserver.py</code> <pre><code>def __init__(self):\n    \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n    InputWebserver.__init__(self, config=NominaWebServer.get_config())\n</code></pre>"}]}