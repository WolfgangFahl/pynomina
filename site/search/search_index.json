{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pynomaina API Documentation","text":""},{"location":"#nomina.date_utils","title":"<code>date_utils</code>","text":"<p>Created on 2024-10-02</p> <p>@author: wf</p>"},{"location":"#nomina.date_utils.DateUtils","title":"<code>DateUtils</code>","text":"<p>date utilities</p> Source code in <code>nomina/date_utils.py</code> <pre><code>class DateUtils:\n    \"\"\"\n    date utilities\n    \"\"\"\n\n    @classmethod\n    def parse_date(\n        cls, date_str: str, date_formats: Optional[List[str]] = None\n    ) -&gt; Optional[str]:\n        \"\"\"\n        Parse the given date string using the provided formats.\n\n        Args:\n            date_str (str): The date string to parse.\n            date_formats (List[str], optional): List of date formats to try.\n                If None, uses a default list of formats.\n\n        Returns:\n            Optional[str]: The parsed date in ISO format (YYYY-MM-DD) or None if parsing fails.\n        \"\"\"\n        if date_formats is None:\n            date_formats = [\n                \"%m.%d.%y\",\n                \"%d.%m.%y\",\n                \"%m/%d/%y\",\n                \"%d/%m/%y\",\n                \"%Y-%m-%d\",\n                \"%Y/%m/%d\",\n                \"%Y-%m-%d %H:%M:%S %z\",  # Added to handle the GnuCash XML format\n            ]\n\n        for date_format in date_formats:\n            try:\n                date_obj = datetime.strptime(date_str, date_format)\n                return date_obj.strftime(\"%Y-%m-%d\")\n            except ValueError:\n                continue\n\n        return None\n\n    @classmethod\n    def split_date_range(\n        cls, start_date: str, end_date: str, num_ranges: int\n    ) -&gt; List[Tuple[str, str]]:\n        \"\"\"\n        Splits a date range into a predefined number of sub-ranges.\n\n        Args:\n            start_date (str): The start date in \"YYYY-MM-DD\" format.\n            end_date (str): The end date in \"YYYY-MM-DD\" format.\n            num_ranges (int): The number of ranges to split into.\n\n        Returns:\n            List[Tuple[str, str]]: A list of tuples representing the sub-ranges.\n        \"\"\"\n        start = datetime.strptime(start_date, \"%Y-%m-%d\")\n        end = datetime.strptime(end_date, \"%Y-%m-%d\")\n        total_days = (end - start).days\n\n        base_range_length = total_days // num_ranges\n        extra_days = total_days % num_ranges\n\n        ranges = []\n        current_start = start\n        for i in range(num_ranges):\n            range_length = base_range_length + (1 if i &lt; extra_days else 0)\n            current_end = current_start + timedelta(days=range_length - 1)\n\n            ranges.append(\n                (current_start.strftime(\"%Y-%m-%d\"), current_end.strftime(\"%Y-%m-%d\"))\n            )\n            current_start = current_end + timedelta(days=1)\n\n        # Ensure the last range ends on the specified end date\n        ranges[-1] = (ranges[-1][0], end_date)\n\n        return ranges\n</code></pre>"},{"location":"#nomina.date_utils.DateUtils.parse_date","title":"<code>parse_date(date_str, date_formats=None)</code>  <code>classmethod</code>","text":"<p>Parse the given date string using the provided formats.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>The date string to parse.</p> required <code>date_formats</code> <code>List[str]</code> <p>List of date formats to try. If None, uses a default list of formats.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The parsed date in ISO format (YYYY-MM-DD) or None if parsing fails.</p> Source code in <code>nomina/date_utils.py</code> <pre><code>@classmethod\ndef parse_date(\n    cls, date_str: str, date_formats: Optional[List[str]] = None\n) -&gt; Optional[str]:\n    \"\"\"\n    Parse the given date string using the provided formats.\n\n    Args:\n        date_str (str): The date string to parse.\n        date_formats (List[str], optional): List of date formats to try.\n            If None, uses a default list of formats.\n\n    Returns:\n        Optional[str]: The parsed date in ISO format (YYYY-MM-DD) or None if parsing fails.\n    \"\"\"\n    if date_formats is None:\n        date_formats = [\n            \"%m.%d.%y\",\n            \"%d.%m.%y\",\n            \"%m/%d/%y\",\n            \"%d/%m/%y\",\n            \"%Y-%m-%d\",\n            \"%Y/%m/%d\",\n            \"%Y-%m-%d %H:%M:%S %z\",  # Added to handle the GnuCash XML format\n        ]\n\n    for date_format in date_formats:\n        try:\n            date_obj = datetime.strptime(date_str, date_format)\n            return date_obj.strftime(\"%Y-%m-%d\")\n        except ValueError:\n            continue\n\n    return None\n</code></pre>"},{"location":"#nomina.date_utils.DateUtils.split_date_range","title":"<code>split_date_range(start_date, end_date, num_ranges)</code>  <code>classmethod</code>","text":"<p>Splits a date range into a predefined number of sub-ranges.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>The start date in \"YYYY-MM-DD\" format.</p> required <code>end_date</code> <code>str</code> <p>The end date in \"YYYY-MM-DD\" format.</p> required <code>num_ranges</code> <code>int</code> <p>The number of ranges to split into.</p> required <p>Returns:</p> Type Description <code>List[Tuple[str, str]]</code> <p>List[Tuple[str, str]]: A list of tuples representing the sub-ranges.</p> Source code in <code>nomina/date_utils.py</code> <pre><code>@classmethod\ndef split_date_range(\n    cls, start_date: str, end_date: str, num_ranges: int\n) -&gt; List[Tuple[str, str]]:\n    \"\"\"\n    Splits a date range into a predefined number of sub-ranges.\n\n    Args:\n        start_date (str): The start date in \"YYYY-MM-DD\" format.\n        end_date (str): The end date in \"YYYY-MM-DD\" format.\n        num_ranges (int): The number of ranges to split into.\n\n    Returns:\n        List[Tuple[str, str]]: A list of tuples representing the sub-ranges.\n    \"\"\"\n    start = datetime.strptime(start_date, \"%Y-%m-%d\")\n    end = datetime.strptime(end_date, \"%Y-%m-%d\")\n    total_days = (end - start).days\n\n    base_range_length = total_days // num_ranges\n    extra_days = total_days % num_ranges\n\n    ranges = []\n    current_start = start\n    for i in range(num_ranges):\n        range_length = base_range_length + (1 if i &lt; extra_days else 0)\n        current_end = current_start + timedelta(days=range_length - 1)\n\n        ranges.append(\n            (current_start.strftime(\"%Y-%m-%d\"), current_end.strftime(\"%Y-%m-%d\"))\n        )\n        current_start = current_end + timedelta(days=1)\n\n    # Ensure the last range ends on the specified end date\n    ranges[-1] = (ranges[-1][0], end_date)\n\n    return ranges\n</code></pre>"},{"location":"#nomina.ledger","title":"<code>ledger</code>","text":"<p>Created on 04.10.2024</p> <p>@author: wf</p>"},{"location":"#nomina.ledger.Account","title":"<code>Account</code>","text":"<p>Represents a ledger account.</p> Source code in <code>nomina/ledger.py</code> <pre><code>@lod_storable\nclass Account:\n    \"\"\"\n    Represents a ledger account.\n    \"\"\"\n\n    account_id: str\n    name: str\n    account_type: str\n    description: Optional[str] = \"\"\n    currency: str = \"EUR\"  # Default to EUR\n    parent_account_id: Optional[str] = None\n</code></pre>"},{"location":"#nomina.ledger.Book","title":"<code>Book</code>","text":"<p>Represents a ledger book containing accounts and transactions.</p> Source code in <code>nomina/ledger.py</code> <pre><code>@lod_storable\nclass Book:\n    \"\"\"\n    Represents a ledger book containing accounts and transactions.\n    \"\"\"\n\n    name: Optional[str] = None\n    owner: Optional[str] = None\n    since: Optional[str] = None\n    url: Optional[str] = None\n    accounts: Dict[str, Account] = field(default_factory=dict)\n    transactions: Dict[str, Transaction] = field(default_factory=dict)\n\n    def __post_init__(self):\n        \"\"\"\n        post construct actions\n        \"\"\"\n\n    def get_stats(self):\n        \"\"\"\n        Get statistics about the Book.\n\n        Returns:\n            dict: A dictionary containing various statistics about the Book.\n        \"\"\"\n        # Calculate date range\n        dates = [\n            datetime.strptime(tx.isodate.split()[0], \"%Y-%m-%d\")\n            for tx in self.transactions.values()\n            if tx.isodate\n        ]\n        if dates:\n            min_date = min(dates).strftime(\"%Y-%m-%d\")\n            max_date = max(dates).strftime(\"%Y-%m-%d\")\n        else:\n            min_date = max_date = None\n\n        return {\n            \"#transactions\": len(self.transactions),\n            \"#accounts\": len(self.accounts),\n            \"date_range\": {\"start_date\": min_date, \"end_date\": max_date},\n        }\n\n    def _get_transaction_histogram(self):\n        \"\"\"\n        Get a histogram of transactions per month.\n\n        Returns:\n            dict: A dictionary with months as keys and transaction counts as values.\n        \"\"\"\n        histogram = Counter()\n        for tx in self.transactions.values():\n            if tx.isodate:\n                month = tx.isodate[:7]  # Extract 'YYYY-MM' part\n                histogram[month] += 1\n        return dict(histogram)\n\n    def filter(self, start_date: str = None, end_date: str = None) -&gt; \"Book\":\n        \"\"\"\n        Filter the transactions based on the given date range.\n\n        Args:\n            start_date (str): The start date in 'YYYY-MM-DD' format.\n            end_date (str): The end date in 'YYYY-MM-DD' format.\n\n        Returns:\n            Book: A new Book object with filtered transactions.\n        \"\"\"\n        filtered_transactions = {}\n\n        for transaction_id, transaction in self.transactions.items():\n            transaction_date = transaction.isodate.split()[\n                0\n            ]  # Extract 'YYYY-MM-DD' part\n\n            in_range = (not start_date or transaction_date &gt;= start_date) and (\n                not end_date or transaction_date &lt;= end_date\n            )\n\n            if in_range:\n                filtered_transactions[transaction_id] = transaction\n\n        filtered_book = deepcopy(self)\n        filtered_book.transactions = filtered_transactions\n        return filtered_book\n\n    def create_account(\n        self,\n        name: str,\n        account_type: str = \"EXPENSE\",\n        parent_account_id: Optional[str] = None,\n    ) -&gt; Account:\n        \"\"\"\n        Create a ledger account with the given parameters.\n\n        Args:\n            name (str): The name of the account.\n            account_type (str): The type of the account. Defaults to \"EXPENSE\".\n            parent_account_id (Optional[str]): The id of the parent account, if any.\n\n        Returns:\n            Account: A new Account object.\n        \"\"\"\n        # Calculate the account ID based on the parent's account ID (if any)\n        if parent_account_id:\n            parent_account = self.lookup_account(parent_account_id)\n            if parent_account:\n                account_id = f\"{parent_account_id}:{name}\"\n            else:\n                raise ValueError(f\"invalid parent account {parent_account_id}\")\n        else:\n            account_id = name  # top level account\n\n        # Create the account\n        account = Account(\n            account_id=account_id,\n            name=name,\n            account_type=account_type,\n            parent_account_id=parent_account_id,\n        )\n        self.add_account(account)\n\n    def add_account(self, account: Account):\n        \"\"\"\n        add the given account\n        \"\"\"\n        self.accounts[account.account_id] = account\n        return account\n\n    def lookup_account(self, account_id: str) -&gt; Optional[Account]:\n        \"\"\"\n        Get the account for the given account id.\n\n        Args:\n            account_id(str): The id of the account to look up.\n\n        Returns:\n            Optional[Account]: The found account or None if not found.\n        \"\"\"\n        return self.accounts.get(account_id)\n</code></pre>"},{"location":"#nomina.ledger.Book.__post_init__","title":"<code>__post_init__()</code>","text":"<p>post construct actions</p> Source code in <code>nomina/ledger.py</code> <pre><code>def __post_init__(self):\n    \"\"\"\n    post construct actions\n    \"\"\"\n</code></pre>"},{"location":"#nomina.ledger.Book.add_account","title":"<code>add_account(account)</code>","text":"<p>add the given account</p> Source code in <code>nomina/ledger.py</code> <pre><code>def add_account(self, account: Account):\n    \"\"\"\n    add the given account\n    \"\"\"\n    self.accounts[account.account_id] = account\n    return account\n</code></pre>"},{"location":"#nomina.ledger.Book.create_account","title":"<code>create_account(name, account_type='EXPENSE', parent_account_id=None)</code>","text":"<p>Create a ledger account with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the account.</p> required <code>account_type</code> <code>str</code> <p>The type of the account. Defaults to \"EXPENSE\".</p> <code>'EXPENSE'</code> <code>parent_account_id</code> <code>Optional[str]</code> <p>The id of the parent account, if any.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Account</code> <code>Account</code> <p>A new Account object.</p> Source code in <code>nomina/ledger.py</code> <pre><code>def create_account(\n    self,\n    name: str,\n    account_type: str = \"EXPENSE\",\n    parent_account_id: Optional[str] = None,\n) -&gt; Account:\n    \"\"\"\n    Create a ledger account with the given parameters.\n\n    Args:\n        name (str): The name of the account.\n        account_type (str): The type of the account. Defaults to \"EXPENSE\".\n        parent_account_id (Optional[str]): The id of the parent account, if any.\n\n    Returns:\n        Account: A new Account object.\n    \"\"\"\n    # Calculate the account ID based on the parent's account ID (if any)\n    if parent_account_id:\n        parent_account = self.lookup_account(parent_account_id)\n        if parent_account:\n            account_id = f\"{parent_account_id}:{name}\"\n        else:\n            raise ValueError(f\"invalid parent account {parent_account_id}\")\n    else:\n        account_id = name  # top level account\n\n    # Create the account\n    account = Account(\n        account_id=account_id,\n        name=name,\n        account_type=account_type,\n        parent_account_id=parent_account_id,\n    )\n    self.add_account(account)\n</code></pre>"},{"location":"#nomina.ledger.Book.filter","title":"<code>filter(start_date=None, end_date=None)</code>","text":"<p>Filter the transactions based on the given date range.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>The start date in 'YYYY-MM-DD' format.</p> <code>None</code> <code>end_date</code> <code>str</code> <p>The end date in 'YYYY-MM-DD' format.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Book</code> <code>Book</code> <p>A new Book object with filtered transactions.</p> Source code in <code>nomina/ledger.py</code> <pre><code>def filter(self, start_date: str = None, end_date: str = None) -&gt; \"Book\":\n    \"\"\"\n    Filter the transactions based on the given date range.\n\n    Args:\n        start_date (str): The start date in 'YYYY-MM-DD' format.\n        end_date (str): The end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        Book: A new Book object with filtered transactions.\n    \"\"\"\n    filtered_transactions = {}\n\n    for transaction_id, transaction in self.transactions.items():\n        transaction_date = transaction.isodate.split()[\n            0\n        ]  # Extract 'YYYY-MM-DD' part\n\n        in_range = (not start_date or transaction_date &gt;= start_date) and (\n            not end_date or transaction_date &lt;= end_date\n        )\n\n        if in_range:\n            filtered_transactions[transaction_id] = transaction\n\n    filtered_book = deepcopy(self)\n    filtered_book.transactions = filtered_transactions\n    return filtered_book\n</code></pre>"},{"location":"#nomina.ledger.Book.get_stats","title":"<code>get_stats()</code>","text":"<p>Get statistics about the Book.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing various statistics about the Book.</p> Source code in <code>nomina/ledger.py</code> <pre><code>def get_stats(self):\n    \"\"\"\n    Get statistics about the Book.\n\n    Returns:\n        dict: A dictionary containing various statistics about the Book.\n    \"\"\"\n    # Calculate date range\n    dates = [\n        datetime.strptime(tx.isodate.split()[0], \"%Y-%m-%d\")\n        for tx in self.transactions.values()\n        if tx.isodate\n    ]\n    if dates:\n        min_date = min(dates).strftime(\"%Y-%m-%d\")\n        max_date = max(dates).strftime(\"%Y-%m-%d\")\n    else:\n        min_date = max_date = None\n\n    return {\n        \"#transactions\": len(self.transactions),\n        \"#accounts\": len(self.accounts),\n        \"date_range\": {\"start_date\": min_date, \"end_date\": max_date},\n    }\n</code></pre>"},{"location":"#nomina.ledger.Book.lookup_account","title":"<code>lookup_account(account_id)</code>","text":"<p>Get the account for the given account id.</p> <p>Parameters:</p> Name Type Description Default <code>account_id(str)</code> <p>The id of the account to look up.</p> required <p>Returns:</p> Type Description <code>Optional[Account]</code> <p>Optional[Account]: The found account or None if not found.</p> Source code in <code>nomina/ledger.py</code> <pre><code>def lookup_account(self, account_id: str) -&gt; Optional[Account]:\n    \"\"\"\n    Get the account for the given account id.\n\n    Args:\n        account_id(str): The id of the account to look up.\n\n    Returns:\n        Optional[Account]: The found account or None if not found.\n    \"\"\"\n    return self.accounts.get(account_id)\n</code></pre>"},{"location":"#nomina.ledger.Split","title":"<code>Split</code>","text":"<p>Represents a split in a transaction.</p> Source code in <code>nomina/ledger.py</code> <pre><code>@lod_storable\nclass Split:\n    \"\"\"\n    Represents a split in a transaction.\n    \"\"\"\n\n    amount: float\n    account_id: str\n    memo: Optional[str] = \"\"\n    reconciled: bool = False\n</code></pre>"},{"location":"#nomina.ledger.Transaction","title":"<code>Transaction</code>","text":"<p>Represents a transaction in the ledger.</p> Source code in <code>nomina/ledger.py</code> <pre><code>@lod_storable\nclass Transaction:\n    \"\"\"\n    Represents a transaction in the ledger.\n    \"\"\"\n\n    isodate: str\n    description: str\n    splits: List[Split] = field(default_factory=list)\n    payee: Optional[str] = None\n    memo: Optional[str] = \"\"\n\n    def total_amount(self) -&gt; float:\n        \"\"\"\n        Calculates the total amount of the transaction.\n        Returns:\n            float: The sum of all split amounts.\n        \"\"\"\n        return sum(split.amount for split in self.splits)\n</code></pre>"},{"location":"#nomina.ledger.Transaction.total_amount","title":"<code>total_amount()</code>","text":"<p>Calculates the total amount of the transaction. Returns:     float: The sum of all split amounts.</p> Source code in <code>nomina/ledger.py</code> <pre><code>def total_amount(self) -&gt; float:\n    \"\"\"\n    Calculates the total amount of the transaction.\n    Returns:\n        float: The sum of all split amounts.\n    \"\"\"\n    return sum(split.amount for split in self.splits)\n</code></pre>"},{"location":"#nomina.version","title":"<code>version</code>","text":"<p>Created on 2024-10-06 @author: wf</p>"},{"location":"#nomina.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for MoneyBrowser</p> Source code in <code>nomina/version.py</code> <pre><code>@dataclass\nclass Version(object):\n    \"\"\"\n    Version handling for MoneyBrowser\n    \"\"\"\n\n    name = \"pynomina\"\n    version = \"0.0.1\"\n    date = \"2024-10-06\"\n    updated = \"2024-10-06\"\n    description = \"Personal finance tool\"\n    authors = \"Wolfgang Fahl\"\n\n    doc_url = \"http://media.bitplan.com/index.php/Fbmoney\"\n    chat_url = \"http://media.bitplan.com/index.php/Fbmoney\"\n    cm_url = \"git.bitplan.com:/srv/git/source/python/fbmoney\"\n\n    license = f\"\"\"Copyright 2024 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"}]}